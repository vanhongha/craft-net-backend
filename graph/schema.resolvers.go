package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"craftnet/graph/model"
	"craftnet/internal/db"
	"craftnet/internal/util"
	"errors"
	"fmt"

	"golang.org/x/crypto/bcrypt"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.User, error) {
	db := db.GetDB()

	var existingUser model.User
	if err := db.QueryRow(ctx, "SELECT id FROM accounts WHERE username = $1", input.Username).Scan(&existingUser.ID); err == nil {
		util.GetLogger().LogErrorWithMsgAndError("username"+input.Username+" already exists", err, false)
		return nil, errors.New("username already exists")
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		util.GetLogger().LogErrorWithMsgAndError("failed to hash password", err, false)
		return nil, errors.New("failed to hash password")
	}

	var newUser model.User
	query := `
        INSERT INTO accounts (username, password_hash, created_at) 
        VALUES ($1, $2, $3)
		RETURNING id, username
    `
	if err := db.QueryRow(ctx, query, input.Username, string(hashedPassword), util.TimeNowJSTZone()).Scan(&newUser.ID, &newUser.Username); err != nil {
		util.GetLogger().LogErrorWithMsgAndError("failed to create user", err, false)
		return nil, errors.New("failed to create user")
	}

	util.GetLogger().LogInfo(fmt.Sprintf("Register new account succesfully. Id: %s, username: %s", newUser.ID, newUser.Username))
	return &newUser, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
