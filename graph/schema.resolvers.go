package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"craftnet/graph/model"
	"craftnet/internal/app/handlers"
	"craftnet/internal/util"
	"errors"
	"fmt"

	"github.com/samber/lo"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.RegisterResponse, error) {
	account, error := handlers.RegisterAccountHandler(input.Username, input.Password)

	if !lo.IsNil(error) {
		return nil, errors.New(error.Message)
	}

	if lo.IsNil(account) {
		errMsg := util.ErrorMessage(util.ERROR_CODE[util.FAIL_TO_CREATE], "account")
		util.GetLogger().LogErrorWithMsg(errMsg, false)
		return nil, errors.New(errMsg)
	}

	fmt.Println(account)
	response := &model.RegisterResponse{
		UserID:    account.User.ID,
		AccountID: account.ID,
		Username:  account.Username,
	}
	return response, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// db := db.GetDB()

	// var account model.Account
	// if err := db.QueryRow(ctx, "SELECT id, username, password_hash FROM accounts WHERE username = $1", input.Username).Scan(&account.Username, &account.PasswordHash); err != nil {
	// 	util.GetLogger().LogErrorWithMsgAndError("invalid username or password", err, false)
	// 	return nil, errors.New("invalid username or password")
	// }

	// if err := bcrypt.CompareHashAndPassword([]byte(account.PasswordHash), []byte(input.Password)); err != nil {
	// 	util.GetLogger().LogErrorWithMsgAndError("invalid username or password", err, false)
	// 	return nil, errors.New("invalid username or password")
	// }

	// token, err := util.GenerateJWT(account.Username, config.GetJwtSecret())

	// if err != nil {
	// 	util.GetLogger().LogErrorWithMsgAndError("failed to generate token", err, false)
	// 	return nil, errors.New("failed to generate token")
	// }

	// fmt.Println("aa")
	// return &model.AuthPayload{
	// 	AccessToken: token,
	// 	User:        account.Username,
	// }, nil

	return nil, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// db := db.GetDB()

	// rows, err := db.Query(ctx, "SELECT id, username FROM accounts")

	// if err != nil {
	// 	util.GetLogger().LogErrorWithMsgAndError("failed to get users", err, false)
	// 	return nil, errors.New("failed to get users")
	// }
	// defer rows.Close()

	// var users []*model.User
	// for rows.Next() {
	// 	var user model.User
	// 	if err := rows.Scan(&user.ID, &user.Username); err != nil {
	// 		util.GetLogger().LogErrorWithMsgAndError("failed to parse user", err, false)
	// 		return nil, errors.New("failed to parse user")
	// 	}
	// 	users = append(users, &user)
	// }

	// return users, nil

	return nil, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
